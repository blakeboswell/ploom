---
title: "Benchmarking"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, eval = TRUE, warning = FALSE, message = FALSE,  echo = FALSE}
library(ggplot2)
library(dplyr)
```


```{r, eval = TRUE, echo = FALSE}

result <- readRDS(system.file("extdata", "lm_benchmark.Rds", package = "ploom"))

N <- max(result$num_obs) / 10^6

colors <- scale_color_viridis_d(option = "D")$palette(5)
colors <- c(colors[1], colors[rep(2:4, each = 2)])
names(colors) <- c(
  "lm"
  , "oomlm"
  , "oomlm + resid"
  , "speedlm"
  , "speedlm + resid"
  , "biglm"
  , "biglm + resid"
)
colors[c("oomlm", "oomlm + resid")] <- "#E00F2E" #"#EC8612" #"#DC4749"
nonresid_andlm <- c(T, T, F, T, F, T, F)
includes_resid <- c(T, F, T, F, T, F, T)

df <- result %>%
  select(expression, min, mean, max, mem_alloc, num_obs) %>%
  dplyr::mutate(
    num_obs       = num_obs / 10^6,
    mem_alloc     = mem_alloc / 10^9,
    nonresid_fit  = (expression %in% (names(colors)[nonresid_andlm])),
    resid_fit     = (expression %in% (names(colors)[includes_resid]))
  )

y_axis_limits <- c(min(result$mean), max(result$mean))

plot_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 18),
    legend.position = "none",
    legend.title = element_blank(),
    axis.title.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)),
    axis.ticks = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  )

x_format <- function(n) {
  as.character(n)
}

```

## Linear Model

This benchmark is meant to represent a typical `lm()` fitting task.  The linear model has 50 features and is fit over 1, 2, 3, 4, and 5 million observations stored in a `tibble`. The technical details are outlined in [details](#Details)

### Fitting Methods Included

The benchmark includes `stats::lm()`, `ploom::oomlm()`, `biglm::biglm()`, and `speedglm::speedlm()`.

The functions  `oomlm()`, `biglm()` and `speedlm()` do not calculate predictions and residuals by default. For parity with `lm()`, the benchmark for these functions includes a call to `predict()` and a residual calculation.

### Results

Although the runtimes are comparable, `oomlm()` is slightly faster than `lm()`.  This indicates that there is no runtime penalty for using the bounded memory fitting of `oomlm()` even when working with `lm()` scale data.

<br>

<!-- #### Fit, Predict and Residuals Calculation Runtime -->

```{r, eval = TRUE, echo = FALSE, fig.width=7, fig.height=3.5, fig.align='center'}

x <- df %>%
  filter(resid_fit) %>%
  rename(
    lower = min
    , upper = max
  )

x %>%
  arrange(expression) %>%
  ggplot(aes(x = num_obs, y = mean, color = expression)) +
  geom_point(size = 3) +
  scale_y_continuous(
    breaks = seq(2, 100, 6),
    limits = y_axis_limits
  ) +
  scale_x_continuous(
    breaks = tail(seq(0, N, by = N / 5), 5),
    label  = x_format,
    limits = c(N * 1/5, N * 1.175)
  ) +
  geom_text(
    data = x %>% filter(num_obs == max(num_obs)),
    aes(label = expression, x = num_obs*1.025, y = mean),
    hjust  = 0
  ) +
  plot_theme +
  labs(
    title    = "Runtime",
    subtitle = "Seconds (mean)",
    x        = "Number of Observations (Million)"
  ) +
  scale_color_manual(values = colors[includes_resid])

```

## Details

The code is available here. The results below were created using the standard R BLAS. 

```

```