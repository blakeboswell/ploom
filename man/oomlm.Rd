% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oomlm.R
\name{oomlm}
\alias{oomlm}
\alias{AIC.oomlm}
\alias{coef.oomlm}
\alias{confint.oomlm}
\alias{deviance.oomlm}
\alias{family.oomlm}
\alias{formula.oomlm}
\alias{predict.oomlm}
\alias{print.oomlm}
\alias{print.summary.oomlm}
\alias{summary.oomlm}
\alias{vcov.oomlm}
\title{Out of memory Linear model}
\usage{
oomlm(formula, data = NULL, weights = NULL, ...)
}
\arguments{
\item{formula}{a symbolic description of the model to be fitted of class
\code{\link[=formula]{formula()}}.}

\item{data}{an optional \code{\link[=oomdata_tbl]{oomdata_tbl()}}, \code{\link[=oomdata_dbi]{oomdata_dbi()}}, \code{\link[=oomdata_con]{oomdata_con()}},
\code{\link[=tibble]{tibble()}}, \code{\link[=data.frame]{data.frame()}}, or \code{\link[=list]{list()}} of observations to fit}

\item{weights}{a one-sided, single term \code{\link[=formula]{formula()}} specifying weights.}

\item{...}{ignored.}
}
\value{
A \code{\link[=oomlm]{oomlm()}} model is perpetually in an \emph{in-progress} state. It is up
to the user to know when fitting is complete. Therefore, only basic
model characteristics are provided as values. Statistics are available on
demand via \code{summary} and \code{extractor} functions.

\item{n}{the number of observations processed.}
\item{df.residual}{the residual degrees of freedom.}
\item{formula}{the \code{\link[=formula]{formula()}} object specifying the linear model.}
\item{terms}{the \code{\link[=terms]{terms()}} object specifying the terms of the linear model.}
\item{weights}{a one-sided, single term \code{\link[=formula]{formula()}} specifying weights.}
\item{call}{the matched call.}
}
\description{
Perform linear regression via Alan Miller's bounded memory QR
factorization algorithm which enables models with \code{p} variables
to be fit in \code{p^2} memory.
}
\details{
The provided \code{\link[=formula]{formula()}} must not contain any data-dependent terms to ensure
consistency across calls to \code{\link[=update]{update()}}. Factors are permitted, but the
levels of the factor must be the same across all data chunks. Empty factor
levels are accepted.
}
\examples{
\donttest{
# `oomglm()` is similar to `lm()` for fitting in memory data

x <- oomlm(mpg ~ cyl + disp, mtcars)
print(x)


# For iteratively updating models, initalize with a call to `oomlm()` and
# update with the `update()` function

chunks <- purrr::pmap(mtcars, list)

y <- oomlm(mpg ~ cyl + disp)

for(chunk in chunks) {
  y <- update(y, chunk)
}

tidy(x)

# `oomdata_tbl()` facilitates iterating through data rows in chunks
chunks  <- oomdata_tbl(mtcars, chunk_size = 1)

# `oomlm()` will automatically fit to all chunks in an `oomdata()` functions
z <- oomlm(mpg ~ cyl + disp, data = chunks)

summary(z)

}
}
\seealso{
\code{\link[=oomglm]{oomglm()}}, \code{\link[=oomdata_tbl]{oomdata_tbl()}}
}
