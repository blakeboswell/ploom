% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oomlm.R
\name{oomlm}
\alias{oomlm}
\alias{AIC.oomlm}
\alias{coef.oomlm}
\alias{confint.oomlm}
\alias{deviance.oomlm}
\alias{family.oomlm}
\alias{formula.oomlm}
\alias{print.oomlm}
\alias{print.summary.oomlm}
\alias{summary.oomlm}
\alias{logLik.oomlm}
\alias{vcov.oomlm}
\alias{BIC.oomlm}
\title{Out of memory Linear model}
\usage{
oomlm(formula, weights = NULL, ...)
}
\arguments{
\item{formula}{a symbolic description of the model to be fitted of class
\code{\link[=formula]{formula()}}.}

\item{weights}{a one-sided, single term \code{\link[=formula]{formula()}} specifying weights.}

\item{...}{ignored.}
}
\value{
A \code{\link[=oomlm]{oomlm()}} model is perpetually in an \emph{in-progress} state. It is up
to the user to know when fitting is complete. Therefore, only basic
model characteristics are provided as values. Statistics are available on
demand via \code{summary} and \code{extractor} functions.

\item{n}{the number of observations processed.}
\item{df.residual}{the residual degrees of freedom.}
\item{formula}{the \code{\link[=formula]{formula()}} object specifying the linear model.}
\item{terms}{the \code{\link[=terms]{terms()}} object specifying the terms of the linear model.}
\item{weights}{a one-sided, single term \code{\link[=formula]{formula()}} specifying weights.}
\item{call}{the matched call.}
}
\description{
Perform linear regression via Alan Miller's bounded memory QR
factorization algorithm which enables models with \code{p} variables
to be fit in \code{p^2} memory.
}
\details{
The provided \code{\link[=formula]{formula()}} must not contain any data-dependent terms to ensure
consistency across calls to \code{\link[=update]{update()}}. Factors are permitted, but the
levels of the factor must be the same across all data chunks. Empty factor
levels are accepted.
}
\examples{
\donttest{
# `oomglm()` are defined with a call to `oomlm()` and fit to data
# with a call to `update()`
x <- oomlm(mpg ~ cyl + disp)
x <- update(x, mtcars)
print(x)


# `oomlm()` models can be fit with more data via subsequent calls
# to the `update()` function
chunks <- purrr::pmap(mtcars, list)

y <- oomlm(mpg ~ cyl + disp)

for(chunk in chunks) {
  y <- update(y, chunk)
}

tidy(x)

# `oomdata_tbl()` facilitates iterating through data rows in chunks
chunks  <- oomdata_tbl(mtcars, chunk_size = 1)

# `update()` will automatically fit over all chunks in an `oomdata()`
# function
z <- oomlm(mpg ~ cyl + disp)
z <- update(z, data = chunks)
summary(z)

}
}
\seealso{
\code{\link[=oomglm]{oomglm()}}, \code{\link[=oomdata_tbl]{oomdata_tbl()}}
}
