% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oomglm.R, R/oomglm_robust.R
\name{oomglm}
\alias{oomglm}
\alias{predict.oomglm}
\alias{print.oomglm}
\alias{print.summary.oomglm}
\alias{summary.oomglm}
\alias{oomglm_robust}
\title{Initialize Updating Generalized Linear model}
\usage{
oomglm(formula, data = NULL, family = gaussian(), weights = NULL,
  start = NULL, ...)

oomglm_robust(formula, data = NULL, family = gaussian(),
  weights = NULL, start = NULL, se_type = "H1", ...)
}
\arguments{
\item{formula}{a symbolic description of the model to be fitted of class
\code{formula}.}

\item{data}{an optional \code{oom_data}, \code{tibble}, \code{dataframe}, \code{list} or
\code{environment}.}

\item{family}{A \code{glm} family object.}

\item{weights}{a one-sided, single term \code{formula} specifying weights.}

\item{start}{starting values for the parameters in the linear predictor.}

\item{...}{ignored.}

\item{se_type}{string indicating what se type to usecan be "HC0", "HC1"
"stata", or "classical". see \link{details}.  default "HC1".}

\item{formula}{a symbolic description of the model to be fitted of class
\code{formula}.}

\item{data}{an optional \code{oom_data}, \code{tibble}, \code{data.frame}, \code{list} or
\code{environment}.}

\item{family}{A \code{glm} family object.}

\item{weights}{a one-sided, single term \code{formula} specifying weights.}

\item{start}{starting values for the parameters in the linear predictor.}

\item{...}{ignored.}
}
\value{
It is up to the user to know when fitting is complete.
Therefore, only basic model characteristics are provided as values with
the \code{oomglm} object. Statistics are available on demand via \code{summary} and
extractor functions.

\item{converged}{Indicates if the IRLS algorithm has converged.}
\item{iter}{The number of iterations of IRLS performed.}
\item{n}{The number observations processed per round of IRLS.}
\item{df.residual}{The residual degrees of freedom.}
\item{df.null}{The residual degrees of freedom.}
\item{formula}{the \code{\link[stats:formula]{stats::formula()}} object specifying the linear model.}
\item{family}{a \code{\link[stats:family]{stats::family()}} object describing the error distribution
and link function used in the model.}
\item{terms}{The \code{\link[stats:terms]{stats::terms()}} object used.}
\item{weights}{The weights \code{\link[stats:formula]{stats::formula()}} provided to the model.}
\item{call}{The matched call.}

It is up to the user to know when fitting is complete.
Therefore, only basic model characteristics are provided as values with
the \code{oomglm} object. Statistics are available on demand via \code{summary} and
extractor functions.

\item{converged}{Indicates if the IRLS algorithm has converged.}
\item{iter}{The number of iterations of IRLS performed.}
\item{n}{The number observations processed per round of IRLS.}
\item{df.residual}{The residual degrees of freedom.}
\item{df.null}{The residual degrees of freedom.}
\item{formula}{the \code{\link[stats:formula]{stats::formula()}} object specifying the linear model.}
\item{family}{a \code{\link[stats:family]{stats::family()}} object describing the error distribution
and link function used in the model.}
\item{terms}{The \code{\link[stats:terms]{stats::terms()}} object used.}
\item{weights}{The weights \code{\link[stats:formula]{stats::formula()}} provided to the model.}
\item{call}{The matched call.}
}
\description{
Perform  generalized linear regression using Alan Miller's bounded memory QR
factorization algorithm which enables models with \code{p} variables
to be fit in \code{p^2} memory.

Perform linear regression via Alan Miller's bounded memory QR
factorization algorithm enables models with \code{p} variables with
\code{p} variables  to be fit with robust standard errors in \code{p^4} memory.
}
\details{
\code{oomglm} initializes an object of class \code{oomglm} inheriting from the
class \code{oomlm}. \code{oomglm} objects are intended to be iteratively
updated with new data via calls to \code{\link[=update]{update()}}. Iterative fitting
over all data updates are performed with the function \code{\link[=iter_weight]{iter_weight()}}.
If \code{data} is provided to the \code{oomglm()} function call, an \code{update()} round
will be performed on initialization.

A \code{oomglm} object can be in various states of fit depending on the number
of seen observations and rounds of IRLS that have been performed.
It is important to view the model within the context of:
the number of observations processed per round of IRLS (\code{n});
the number of IRLS iterations that have been performed (\code{iter});
and if the IRLS algorithm has converged (\code{converged}).

\code{oomglm} initializes an object of class \code{oomglm} inheriting from the
class \code{oomlm}. \code{oomglm} objects are intended to be iteratively
updated with new data via calls to \code{\link[=update]{update()}}. Iterative fitting
over all data updates are performed with the function \code{\link[=iter_weight]{iter_weight()}}.
If \code{data} is provided to the \code{oomglm()} function call, an \code{update()} round
will be performed on initialization.

A \code{oomglm} object can be in various states of fit depending on the number
of seen observations and rounds of IRLS that have been performed.
It is important to view the model within the context of:
the number of observations processed per round of IRLS (\code{n});
the number of IRLS iterations that have been performed (\code{iter});
and if the IRLS algorithm has converged (\code{converged}).
}
\examples{
\donttest{
# The `oomglm()` function fits generalized linear models via 
# Iteratively Weighted Least Squares (IWLS).  

# When fitting in-memory data the process is similar to `oomlm()` but we use the 
# function `iter_weight()` instead of `update()`. `iter_weight()` fits the model
# via iterative passes over the data until convergence.

# initialize the model
x <- oomglm(mpg ~ cyl + disp)

# re-weight 8 times or until convergence
x <- iter_weight(x, mtcars, max_iter = 8)

# To fit data in chunks, use `oom_data()`:

# initialize the model
x    <- oomglm(mpg ~ cyl + disp)
feed <- oom_data(mtcars, chunk_size = 10)

# iteratively reweight model
x <- iter_weight(x, feed, max_iter = 8)

# The `iter_weight()` process can also be implemented directly with
# component `ploom` functions:

x    <- oomglm(mpg ~ cyl + disp)
feed <- oom_data(mtcars, chunk_size = 10)

# a first pass over the data
x <- init_weight(x)
x <- weight(x, feed)
x <- end_weight(x)
x

# a second pass over the data
x <- init_weight(x)
x <- weight(x, feed)
x <- end_weight(x)
x

# This is meant to be useful when debugging / evaluating models with long 
# runtimes by exposing the individual steps of the model process for inspection. 

}
\donttest{
# The `oomglm()` function fits generalized linear models via 
# Iteratively Weighted Least Squares (IWLS).  

# When fitting in-memory data the process is similar to `oomlm()` but we use the 
# function `iter_weight()` instead of `update()`. `iter_weight()` fits the model
# via iterative passes over the data until convergence.

# initialize the model
x <- oomglm(mpg ~ cyl + disp)

# re-weight 8 times or until convergence
x <- iter_weight(x, mtcars, max_iter = 8)

# To fit data in chunks, use `oom_data()`:

# initialize the model
x    <- oomglm(mpg ~ cyl + disp)
feed <- oom_data(mtcars, chunk_size = 10)

# iteratively reweight model
x <- iter_weight(x, feed, max_iter = 8)

# The `iter_weight()` process can also be implemented directly with
# component `ploom` functions:

x    <- oomglm(mpg ~ cyl + disp)
feed <- oom_data(mtcars, chunk_size = 10)

# a first pass over the data
x <- init_weight(x)
x <- weight(x, feed)
x <- end_weight(x)
x

# a second pass over the data
x <- init_weight(x)
x <- weight(x, feed)
x <- end_weight(x)
x

# This is meant to be useful when debugging / evaluating models with long 
# runtimes by exposing the individual steps of the model process for inspection. 

}
}
\seealso{
\code{\link[=oomlm]{oomlm()}}

\code{\link[=oomlm]{oomlm()}}
}
